
---
title: '每天进步一点点： Python 如何实现程序原地刷新'
permlink: 5qvp2i-python
catalog: true
toc_nav_num: true
toc: true
date: 2018-02-09 13:50:54
categories:
- python
tags:
- python
- ascii
- cn-programming
- programming
- cn
thumbnail: https://steemitimages.com/DQmXQzDMbiUMFVUWX8A9qodarzSPfjvgJH9NufV46enHncb/image.png
sidebar:
    right:
        sticky: true
widgets:
    -
        type: toc
        position: right
---


之前我折腾了一通比特股的节点，终于咱也用上了自己的私有节点啦。用上私有节点之后，腰不酸了，背不疼了，腿也不抽筋啦，当然了，每月40刀的VPS费，还是很让人心疼不已的。

![](https://steemitimages.com/DQmXQzDMbiUMFVUWX8A9qodarzSPfjvgJH9NufV46enHncb/image.png)
（图源：[bing.com](bing.com)）

虽然用上了私有节点，但是我亲历了[比特股爆仓事件](https://steemit.com/bitshares/@oflyhigh/5eelwj-bts)之后，我觉得我真的不适合交易，无论做啥操作，我基本上都能准确的和市场趋势保持相反。但是弄个私有节点啥也不干有点浪费，那就折腾玩吧。

话说，之前我曾经写了个简单的脚本，[查看指定市场当前订单情况](https://steemit.com/bitshares/@oflyhigh/mxqeh-bitshares)，但是呢，但是这个脚本需要我每次手动运行一下，生成报表。我也有想过用循环随时刷新，但是因为当时用的第三方节点，延迟大概有3-5秒的样子，所以随时刷新是不现实的。

但是有了私有节点之后，我的这个想法又再次萌生，这次不存在延迟的问题了，是不是可以考虑做一个随时刷新的市场行情列表啦。而既然延迟不是问题，那么随时刷新就剩一个问题需要解决了，那就是在原地刷新，不然一屏屏的数据滚来滚去，我估计我是受不了的。

# 原地刷新的思路

那么如何解决原地刷新的问题呢？我首先想到的就是ASCII码表里的**`回车、换行、退格`**。

退格没啥说的啦，但是很多朋友搞不清楚回车、换行有什么区别，我这里简单说一下：
* 回车，即让光标回到行首
比如：`print("I am oflyhigh\r", end='')`
![](https://steemitimages.com/DQma8HiewLPxn4FSxdJTJ2TwakGbfphBTXLGCXpoj8rHPTF/image.png)
>A carriage return, sometimes known as a cartridge return and often shortened to CR, `<CR> `or return, is a control character or mechanism used to reset a device's position to the beginning of a line of text. It is closely associated with the line feed and newline concepts, although it can be considered separately in its own right.
* 换行，开启新的一行
比如：`print("I am oflyhigh\n", end='')`
![](https://steemitimages.com/DQmQDiMkrNCVRC4f2mYvZ4UGN5EDpqp1CUd2L7oucru2qwB/image.png)
>Newline (frequently called line ending, end of line (EOL), line feed, or line break) is a control character in a character encoding specification, like e.g. ASCII. It is used to signify the end of a line of text and the start of a new one. Text editors set this special character when pressing the Enter key.

**(引用部分为维基百科的解释)**

有了上述了解后，我们就可以：**把原地刷新问题处理成将光标移回到起始点问题**

比如，这段代码：
```
print("I am oflyhigh\n", end='')
print("I am oflyhigh\n", end='')
print("\r\b\r\b\r", end='')
```
光标又回到原点啦
![](https://steemitimages.com/DQmcX3iLWPPXzvbe1Kht5S9P8zBAkx8AV8psCv6yAwew12o/image.png)

以下这组代码，可以实现程序原地刷新
```
import time
for i in range(1,100):
        print("I am oflyhigh\n", end='')
        print(f"Seconds: {i}\n", end='')
        print("\r\b\r\b\r", end='')
        time.sleep(1)
```
![](https://steemitimages.com/DQmWh6wnQZQewHkmiRKpkd95Gr8RTwL2BVD9XHGnX1Sunbr/image.png)

# 清理屏幕区域

到了这里，似乎我们可以实现实时刷新的市场行情信息了。但是，我在实际运行过程中却发现一个奇怪的问题。

本来报价列表应该是这样的：
![](https://steemitimages.com/DQmdCSxLC2Pbt9yVFkzMci9pM5iedDgaxSxzyFjTZbxh95Q/image.png)

但是跑着跑着却变成这样：
![](https://steemitimages.com/DQmPUcNRsRU9Qj4pPzTy8ivYZAB72vj9NaUTreodEm6p385/image.png)
（后边多一列或者多列竖线）

我研究了半天，才研究明白，原来列表的宽度有有可能变化的，比如出现一两个大单，这样字符串就特别长，把列表撑宽了，然后大单被消灭掉，列表恢复原来的宽度，但是之前写在屏幕上的数据还在，就出现这样的情况喽。

于是乎我又想了个办法，就是***先输出一排排的空格，将屏幕指定区域清空，然后再重新输出数据，一切OK。***

# 总结

* Python 程序原地刷新问题可以换成光标控制问题。
* 新输出的内容比原位置内容短，就会在行尾出现无意义内容。
* 在屏幕上输出N个长度的空格，可以清空指定区域。
* 可以将**`光标复位、清空内容、光标复位`**封装为**`清屏回位函数`**
* 配合**`清屏回位函数`**与程序的输出，可以轻易实现程序原地刷新





# 相关链接

* [更新了一下bitshares节点以及轻钱包](https://steemit.com/bitshares/@oflyhigh/7vyz83-bitshares)
* [每天进步一点点：bitshares中生成指定市场的订单列表](https://steemit.com/bitshares/@oflyhigh/mxqeh-bitshares)
* https://en.wikipedia.org/wiki/ASCII
* https://en.wikipedia.org/wiki/Backspace
* https://en.wikipedia.org/wiki/Carriage_return
* https://en.wikipedia.org/wiki/Newline

- - -

This page is synchronized from the post: [每天进步一点点： Python 如何实现程序原地刷新](https://steemit.com/@oflyhigh/5qvp2i-python)
